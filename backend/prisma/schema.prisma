generator client {
  provider   = "prisma-client-js"
  engineType = "library"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                 String            @id @default(uuid())
  email              String            @unique
  password_hash      String?
  name               String
  avatar_url         String?
  created_at         DateTime          @default(now())
  google_id          String?           @unique
  apple_subject_id   String?           @unique
  youtube_channel_id String?
  isYoutubeMember    Boolean           @default(false)
  lastYoutubeSync    DateTime?
  points             Int               @default(0)
  monthly_points     Int               @default(0)
  yearly_points      Int               @default(0)
  monthly_rank_delta Int               @default(0)
  role               SystemRole        @default(MEMBER)
  yearly_rank_delta  Int               @default(0)
  owned_leagues      League[]          @relation("LeagueOwner")
  league_memberships LeagueMember[]
  picks              Pick[]
  ranking_snapshots  RankingSnapshot[]
  memberships        UserMembership[]
}

model SystemSettings {
  key         String  @id
  value       String
  description String?
}

model ManagedChannel {
  id               String           @id @default(uuid())
  name             String
  youtube_id       String           @unique
  refresh_token    String
  is_active        Boolean          @default(true)
  last_sync_status String?
  members          UserMembership[]
}

model UserMembership {
  id                 String         @id @default(uuid())
  user_id            String
  managed_channel_id String
  tier_name          String
  is_active          Boolean        @default(true)
  last_updated_at    DateTime       @updatedAt
  channel            ManagedChannel @relation(fields: [managed_channel_id], references: [id])
  user               User           @relation(fields: [user_id], references: [id])

  @@unique([user_id, managed_channel_id])
}

model Event {
  id                    String      @id
  title                 String
  subtitle              String?
  date                  DateTime
  end_date              DateTime?
  location              String?
  banner_url            String?
  banner_settings       Json?
  status                EventStatus @default(SCHEDULED)
  lock_status           LockStatus  @default(OPEN)
  lock_time             DateTime?
  cascade_start_time    DateTime?
  is_calculating_points Boolean     @default(false)
  fights                Fight[]
  picks                 Pick[]
}

model Fighter {
  id          String  @id
  name        String
  nickname    String?
  image_url   String?
  wins        Int     @default(0)
  losses      Int     @default(0)
  draws       Int     @default(0)
  nc          Int     @default(0)
  fights_as_a Fight[] @relation("FighterA")
  fights_as_b Fight[] @relation("FighterB")
  won_fights  Fight[] @relation("Winner")
  picked_by   Pick[]
}

model Fight {
  id               String       @id
  event_id         String
  fighter_a_id     String
  fighter_b_id     String
  winner_id        String?
  category         String?
  weight_class     String?
  rounds           Int
  is_title         Boolean      @default(false)
  result           FightResult?
  method           String?
  round_end        String?
  time             String?
  order            Int?         @default(0)
  points           Int?         @default(10)
  lock_status      String?      @default("OPEN")
  custom_lock_time DateTime?
  video_url        String?
  event            Event        @relation(fields: [event_id], references: [id])
  fighter_a        Fighter      @relation("FighterA", fields: [fighter_a_id], references: [id])
  fighter_b        Fighter      @relation("FighterB", fields: [fighter_b_id], references: [id])
  winner           Fighter?     @relation("Winner", fields: [winner_id], references: [id])
  picks            Pick[]
}

model Pick {
  id            String  @id @default(uuid())
  user_id       String
  fight_id      String
  event_id      String
  fighter_id    String
  method        String
  round         String
  points_earned Int     @default(0)
  event         Event   @relation(fields: [event_id], references: [id])
  fight         Fight   @relation(fields: [fight_id], references: [id])
  fighter       Fighter @relation(fields: [fighter_id], references: [id])
  user          User    @relation(fields: [user_id], references: [id])

  @@unique([user_id, fight_id])
}

model League {
  id          String         @id @default(uuid())
  name        String
  description String?
  invite_code String         @unique
  logo_url    String?
  created_at  DateTime       @default(now())
  owner_id    String
  is_system   Boolean        @default(false)
  owner       User           @relation("LeagueOwner", fields: [owner_id], references: [id])
  members     LeagueMember[]
}

model LeagueMember {
  id        String     @id @default(uuid())
  league_id String
  user_id   String
  role      LeagueRole @default(MEMBER)
  joined_at DateTime   @default(now())
  league    League     @relation(fields: [league_id], references: [id])
  user      User       @relation(fields: [user_id], references: [id])

  @@unique([league_id, user_id])
}

model RankingSnapshot {
  id        String   @id @default(uuid())
  user_id   String
  league_id String   @default("global-league")
  period    String
  type      String
  rank      Int
  points    Int
  createdAt DateTime @default(now())
  user      User     @relation(fields: [user_id], references: [id])

  @@index([period, type, league_id])
  @@index([user_id])
}

enum SystemRole {
  OWNER
  ADMIN
  MEMBER
}

enum EventStatus {
  SCHEDULED
  LIVE
  COMPLETED
}

enum LockStatus {
  OPEN
  CLOSED
  LOCKED
  SCHEDULED
  CASCADE
}

enum FightResult {
  WIN
  DRAW
  NC
}

enum LeagueRole {
  OWNER
  ADMIN
  MEMBER
}
